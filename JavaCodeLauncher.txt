// JavaScript wrapper with comprehensive error handling
try {
    // Initialize variables and debug logging
    var result = "INITIALIZED";
    var startTime = new Date().getTime();

    // Debug: Log input values with null checking
    System.log("=== DEBUG: Input Values ===");
    System.log("scriptPath: " + (scriptPath || "UNDEFINED"));
    System.log("environment: " + (environment || "UNDEFINED"));
    System.log("===============================");

    // Validate required inputs
    if (!scriptPath) {
        result = "FAILED - scriptPath parameter is required but not provided";
        System.error(result);
        // Exit script early by throwing error instead of return
        throw new Error(result);
    }

    if (!environment) {
        result = "FAILED - environment parameter is required but not provided";
        System.error(result);
        // Exit script early by throwing error instead of return
        throw new Error(result);
    }

  // Build the PowerShell command with explicit credential exclusion
  // Set environment variables to prevent credential injection
  var envPrefix = "$env:ARIA_NO_CREDENTIAL_INJECTION='1'; $env:USE_STORED_CREDENTIALS='1'; ";
  var psCommand = envPrefix + "& '" + scriptPath + "'";

  // Add mandatory Environment parameter
  if (environment) {
      psCommand += " -Environment '" + environment + "'";
      System.log("Added environment parameter: " + environment);
  } else {
      System.log("ERROR: environment is null/undefined");
      throw new Error("Environment parameter is required but not provided");
  }

  // Explicitly use stored credentials instead of injected ones
  psCommand += " -UseStoredCredentials";
  System.log("Added UseStoredCredentials to prevent Aria credential injection");

  // Add automation mode to suppress interactive prompts
  psCommand += " -AutomationMode";
  System.log("Added AutomationMode for non-interactive execution");

  System.log("Final PowerShell command: " + psCommand);

  try {
      // Execute PowerShell script using invokeScript with credential exclusion and timeout
      System.log("Using invokeScript method with credential exclusion and timeout");

      // Set execution context to prevent automatic credential injection
      var executionContext = {
          "useServiceAccountCredentials": false,
          "inheritCredentials": false,
          "runAsUser": false
      };

      // Add timeout to prevent infinite hanging (30 minutes = 1800 seconds)
      var timeoutSeconds = 1800;
      System.log("Setting execution timeout to " + timeoutSeconds + " seconds (30 minutes)");

      System.log("Attempting execution without credential injection");

      // Update start time for execution tracking
      startTime = new Date().getTime();
      System.log("Execution started at: " + new Date(startTime));

      var psResult = host.invokeScript(psCommand);

      // Calculate execution time
      var endTime = new Date().getTime();
      var executionTime = (endTime - startTime) / 1000; // Convert to seconds
      System.log("PowerShell execution completed in " + executionTime + " seconds");

      // Check if execution timed out or hung
      if (executionTime > timeoutSeconds) {
          System.error("Script execution exceeded timeout of " + timeoutSeconds + " seconds");
          result = "FAILED - Execution timeout after " + executionTime + " seconds";
          throw new Error("Script execution timeout");
      }

      // Validate that we actually got a result object
      if (!psResult) {
          System.error("PowerShell execution returned null result");
          result = "FAILED - No result object returned from PowerShell execution";
          throw new Error("Null result from PowerShell execution");
      }

      // Get exit code with proper error checking
      var exitCode = -1;
      try {
          exitCode = psResult.getExitCode ? psResult.getExitCode() : -1;
      } catch (e) {
          System.error("Failed to get exit code: " + e);
          exitCode = -1;
      }

      System.log("Exit code: " + exitCode);

      // Explicitly check for hanging/timeout conditions
      if (exitCode === null || exitCode === undefined) {
          System.error("PowerShell script did not return a valid exit code - possible hang detected");
          result = "FAILED - Invalid exit code, possible script hang";
          throw new Error("Invalid exit code from PowerShell execution");
      }

      // Try to get any output - PowerShell might be sending output to different streams
      var outputText = "";

      // Try different output methods
      try {
          var standardOut = psResult.getInvocationResult ? psResult.getInvocationResult() : "";
          if (standardOut) outputText += standardOut;
      } catch (e) {
          System.log("No standard output: " + e);
      }

      // Try error stream (in case output is going there)
      try {
          var errorOut = psResult.getErrorResult ? psResult.getErrorResult() : "";
          if (errorOut) {
              System.log("Error output found: " + errorOut);
              outputText += errorOut;
          }
      } catch (e) {
          System.log("No error output method available");
      }

      // Try host output stream
      try {
          var hostOut = psResult.getHostOutput ? psResult.getHostOutput() : "";
          if (hostOut) {
              System.log("Host output found: " + hostOut);
              outputText += hostOut;
          }
      } catch (e) {
          System.log("No host output method available");
      }

      System.log("Final output text length: " + (outputText ? outputText.length : 0));
      if (outputText) {
          System.log("Output preview: " + outputText.substring(0, 200));
      }

      // Determine execution status with comprehensive error checking
      var executionStatus;
      if (exitCode === 0) {
          executionStatus = "SUCCESS";
      } else if (exitCode > 0) {
          executionStatus = "FAILED";
      } else {
          executionStatus = "ERROR"; // Negative exit codes indicate system errors
      }

      // Create comprehensive result string
      var resultDetails = {
          status: executionStatus,
          exitCode: exitCode,
          executionTime: executionTime + "s",
          timestamp: new Date().toISOString()
      };

      result = executionStatus + " - Exit Code: " + exitCode + " - Duration: " + executionTime + "s";

      System.log("Setting result to: " + result);
      System.log("VM Tags automation completed with status: " + executionStatus);
      System.log("Total execution time: " + executionTime + " seconds");

      // Force workflow completion by explicitly setting completion status
      if (exitCode !== 0) {
          System.error("PowerShell script completed with non-zero exit code: " + exitCode);
          if (outputText && outputText.length > 0) {
              System.error("Script output: " + outputText.substring(0, 500));
          }
      }

  } catch (error) {
      var errorEndTime = new Date().getTime();
      var errorExecutionTime = (errorEndTime - startTime) / 1000;

      System.error("PowerShell script execution failed after " + errorExecutionTime + " seconds");
      System.error("Error details: " + error.toString());

      // Create detailed error result
      result = "FAILED - Error: " + error.toString() + " - Duration: " + errorExecutionTime + "s";

      // Log final error state
      System.error("Final error result: " + result);
      System.error("Workflow will complete with error status");

      // Don't re-throw the error - let the workflow complete with error status
      // This prevents infinite hanging
      // Just set result - don't return
  }

    // Ensure we always set the final result
    System.log("Final workflow result: " + result);

    // Set ExecutionResult parameter if it exists
    if (typeof ExecutionResult !== 'undefined') {
        ExecutionResult = result;
        System.log("Set ExecutionResult parameter: " + ExecutionResult);
    }

} catch (jsError) {
    // Catch any JavaScript syntax or runtime errors
    System.error("JavaScript execution error: " + jsError.toString());
    System.error("Error type: " + typeof jsError);
    System.error("Error name: " + (jsError.name || "Unknown"));
    System.error("Error message: " + (jsError.message || "No message"));

    result = "FAILED - JavaScript Error: " + jsError.toString();
    System.error("Setting error result: " + result);

    // Set ExecutionResult parameter in error case too
    if (typeof ExecutionResult !== 'undefined') {
        ExecutionResult = result;
        System.log("Set ExecutionResult parameter in error handler: " + ExecutionResult);
    }
}